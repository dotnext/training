<!DOCTYPE html>
<html>
  <head>
    <title>Kubernetes</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
        <link rel="stylesheet" type="text/css" href="../css/default.css">
  </head>
  <body>
    <textarea id="source">
      # Kubernetes Constructs

      ---

      #What's in a Pod?

      TBD
      
      ---
      
      #A basic pod .yaml
      
   
      
      ---
      
      # The Pause Container
      
      ---
      
      # Kubernetes Networking
      
      ---
      # Kubernetes API
      
      
      ---
      
      # Namespaces
      
      
      ---
      
      # Deployments
      
      A Deployment controller provides declarative updates for Pods and ReplicaSets.
      
      ---
      
      # Volumes
      
      ---
      
      # Persistent Volumes
      
      * Create Persistent Volume (pv) resource
      * Create Persistence Volume Claim (pvc)
      * Write a manifest for a pod that uses this (persistent volume claim as a volume type)
      
      Since Kubernetes 1.6 you could use dynamic provisioning: with this Kubernetes creates a persistent volume corresponding to the claim made by the users. 
      Dynamic provisioning is supported by an API (StorageClass) that lets the administrator define a persistence volume provisoner of a certain type, then the user can self serve from that.
      ---
      
      # Secrets
      
      Some data (such as passwords, OAuth tokens, and ssh keys) must be handled with care so Kubernetes offers a Secrets API.
      
      This way you can keep configuration separated from the code in a true 12F way: 
      the secret is created independently from the pod/pods that uses it ;)
      
      * Secrets are stored in the tmpfs of the container host running the pod and are made available only to the specific container(s) needing them.
      * Secrets are written unencrypted in etcd (as of Jan 2018)
      * Remember that base64 encoding is *NOT* an un acceptable form of encryption
      * Secret files can also be mounted as a volume type
      
      Check here for the (latest) best practices on handling secrets:
      https://kubernetes.io/docs/concepts/configuration/secret/#security-properties
      
      ---
      # A secret yaml Example
      
      ```
      apiVersion: v1
      kind: Secret
      metadata:
          name: mysecret
          type: Opaque
      data:
          username: YWRtaW4=
          password: MWYyZDFlMmU2N2Rm
      ```
      ---

      # Demo


      ---


      # Pushing an Application to Kubernetes



      ---



      # Now you!

      ```
      git clone 
      cd hello-python
      TBD

      ```


    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
    remark.macros.scale = function (percentage) {
      var url = this;
      return '<img src="' + url + '" style="width: ' + percentage + '" />';
    };
      var slideshow = remark.create();
    </script>
  </body>
</html>

